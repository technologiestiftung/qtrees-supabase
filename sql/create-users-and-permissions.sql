-- setup is derived from https://github.com/supabase/supabase/blob/a45a8114c1e38af87de4b1af820c97a883777364/examples/nextjs-slack-clone/readme.md
-- access scope types
create type public.app_permission as enum ('tree.update');
-- for example ALTER TYPE public.app_permission ADD VALUE 'tree.delete' AFTER 'redtree.update';
create type public.app_role as enum ('admin', 'editor', 'viewer');
--
-- create a table for user profiles
create table public.profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3),
  constraint special_char check ("username" ~* '^[a-za-z0-9_-]*$')
);
create unique index user_name_case_insensitive on "public"."profiles" (lower(username));
--
--
-- User Roles
create table public.user_roles (
  id bigint generated by default as identity not null primary key,
  user_id uuid references public.profiles on delete cascade not null,
  role public.app_role not null,
  unique(user_id, role)
);
comment on table public.user_roles is 'Applicatiopn roles for each user';
--
--
--
-- Role Permissions
create table public.role_permissions (
  id bigint generated by default as identity not null primary key,
  role app_role not null,
  permission public.app_permission not null,
  unique(role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role';
--
--
--
--authorization with role based access control (RBAC)
create function public.authorizate(
  requested_permission public.app_permission,
  user_id uuid
) returns boolean as $$
declare bind_permissions int;
begin
select count(*)
from public.permissions
  inner join public.user_roles on role_permissions.role = user_roles.role
where role_permissions.permission = authorize.requested_permission
  and user_roles.user_id = authorize.user_id into bind_permissions;
return bind_permissions > 0;
end;
$$ language plpgsql security definer;
--
--
--
-- secure the tables
alter table public.profiles enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
-- Row level security on profiles (RLS)
create policy "public profiles are viewable by everyone." on profiles for
select using (true);
create policy "users can insert their own profile." on profiles for
insert with check (auth.uid() = id);
create policy "users can update own profile." on profiles for
update using (auth.uid() = id);
-- RLS on user_roles
create policy "Allow individual read access" on public.user_roles for
select using (auth.uid() = user_id);
--
--
--
-- triggers and functions
-- inserts a row into public.users and assigns roles
create or replace function public.handle_new_user() returns trigger as $$
declare is_admin boolean;
begin
insert into public.users (id, username)
values (new.id, new.email);
select count(*) = 1 -- from auth.users into is_admin;
insert into public.user_roles (user_id, role)
values (new.id, 'viewer');
return new;
end;
$$ language plpgsql security definer;
-- trigger the function every time a user is created
create trigger on_auth_user_created
after
insert on auth.users for each row execute procedure public.handle_new_user();
-- -- set up realtime!
-- begin;
--   drop publication if exists supabase_realtime;
--   create publication supabase_realtime;
-- commit;
-- alter publication supabase_realtime
--   add table profiles;
-- -- set up storage!
-- insert into storage.buckets (id, name)
--   values ('avatars', 'avatars');
-- create policy "avatar images are publicly accessible." on storage.objects
--   for select using (bucket_id = 'avatars');
-- create policy "anyone can upload an avatar." on storage.objects
--   for insert with check (bucket_id = 'avatars');
-- create policy "anyone can update an avatar." on storage.objects
--   for update with check (bucket_id = 'avatars');